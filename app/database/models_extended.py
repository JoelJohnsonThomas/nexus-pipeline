"""
Extended database models for AI News Aggregator pipeline.
Includes LLM summaries, vector embeddings, and email subscriptions.
"""
from datetime import datetime
from sqlalchemy import Column, Integer, String, Text, DateTime, Boolean, ForeignKey, JSON, Enum, Index
from sqlalchemy.orm import relationship
import enum

try:
    from pgvector.sqlalchemy import Vector
except ImportError:
    # Fallback if pgvector is not installed yet
    Vector = None

from app.database.base import Base


class ProcessingStatus(enum.Enum):
    """Enum for article processing status"""
    PENDING = "pending"
    EXTRACTING = "extracting"
    SUMMARIZING = "summarizing"
    EMBEDDING = "embedding"
    COMPLETED = "completed"
    FAILED = "failed"


class ArticleSummary(Base):
    """
    LLM-generated article summaries.
    Stores summaries and key points generated by different LLM models.
    """
    __tablename__ = "article_summaries"

    id = Column(Integer, primary_key=True, index=True)
    article_id = Column(Integer, ForeignKey("articles.id", ondelete="CASCADE"), nullable=False, index=True)
    model = Column(String(50), nullable=False)  # e.g., gemini-1.5-flash, claude-3-haiku
    summary = Column(Text, nullable=False)
    key_points = Column(JSON, nullable=True)  # Array of bullet points
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Relationship to article
    article = relationship("Article", back_populates="summaries")

    def __repr__(self):
        return f"<ArticleSummary(id={self.id}, article_id={self.article_id}, model='{self.model}')>"


class ArticleEmbedding(Base):
    """
    Vector embeddings for semantic search.
    Stores embeddings generated from article summaries.
    """
    __tablename__ = "article_embeddings"

    id = Column(Integer, primary_key=True, index=True)
    article_id = Column(Integer, ForeignKey("articles.id", ondelete="CASCADE"), nullable=False, unique=True, index=True)
    embedding = Column(Vector(384) if Vector else Text, nullable=False)  # 384 dimensions for all-MiniLM-L6-v2
    model = Column(String(50), nullable=False, default="all-MiniLM-L6-v2")
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Relationship to article
    article = relationship("Article", back_populates="embedding", uselist=False)
    
    # Index for vector similarity search
    __table_args__ = (
        Index('idx_embedding_vector', 'embedding', postgresql_using='ivfflat'),
    ) if Vector else tuple()

    def __repr__(self):
        return f"<ArticleEmbedding(id={self.id}, article_id={self.article_id}, model='{self.model}')>"


class EmailFrequency(enum.Enum):
    """Enum for email digest frequency"""
    DAILY = "daily"
    WEEKLY = "weekly"
    CUSTOM = "custom"


class EmailSubscription(Base):
    """
    User email subscription preferences.
    Manages who receives digests and their preferences.
    """
    __tablename__ = "email_subscriptions"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), nullable=False, unique=True, index=True)
    name = Column(String(255), nullable=True)  # Subscriber name (optional)
    frequency = Column(Enum(EmailFrequency), nullable=False, default=EmailFrequency.DAILY)
    source_filters = Column(JSON, nullable=True)  # Array of source IDs to include
    is_active = Column(Boolean, default=True, nullable=False, index=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    last_sent_at = Column(DateTime, nullable=True)
    
    # Relationship to deliveries
    deliveries = relationship("EmailDelivery", back_populates="subscription", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<EmailSubscription(id={self.id}, email='{self.email}', frequency={self.frequency.value})>"


class DeliveryStatus(enum.Enum):
    """Enum for email delivery status"""
    PENDING = "pending"
    SENT = "sent"
    FAILED = "failed"
    BOUNCED = "bounced"


class EmailDelivery(Base):
    """
    Email delivery tracking and history.
    Records all sent digests for auditing and analytics.
    """
    __tablename__ = "email_deliveries"

    id = Column(Integer, primary_key=True, index=True)
    subscription_id = Column(Integer, ForeignKey("email_subscriptions.id", ondelete="CASCADE"), nullable=False, index=True)
    status = Column(Enum(DeliveryStatus), nullable=False, default=DeliveryStatus.PENDING)
    articles_count = Column(Integer, nullable=False, default=0)
    articles_ids = Column(JSON, nullable=True)  # Array of article IDs included
    sent_at = Column(DateTime, nullable=True)
    error_message = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Relationship to subscription
    subscription = relationship("EmailSubscription", back_populates="deliveries")

    def __repr__(self):
        return f"<EmailDelivery(id={self.id}, subscription_id={self.subscription_id}, status={self.status.value})>"


class ProcessingQueue(Base):
    """
    Message queue state tracking.
    Tracks article processing through the pipeline stages.
    """
    __tablename__ = "processing_queue"

    id = Column(Integer, primary_key=True, index=True)
    article_id = Column(Integer, ForeignKey("articles.id", ondelete="CASCADE"), nullable=False, index=True)
    status = Column(Enum(ProcessingStatus), nullable=False, default=ProcessingStatus.PENDING, index=True)
    current_stage = Column(String(50), nullable=True)  # extraction, summarization, embedding
    retry_count = Column(Integer, nullable=False, default=0)
    error_message = Column(Text, nullable=True)
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    # Relationship to article
    article = relationship("Article", back_populates="processing_queue", uselist=False)

    def __repr__(self):
        return f"<ProcessingQueue(id={self.id}, article_id={self.article_id}, status={self.status.value})>"
